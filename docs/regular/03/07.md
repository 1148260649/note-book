# 11丨如何理解正则的匹配原理以及优化原则？

这一节课我们一起来学习正则匹配原理相关的内容，以及在书写正则时的一些优化方法。

这节课我主要给你讲解一下正则匹配过程，回顾一下之前讲的回溯，以及 DFA 和 NFA 引擎的工作方式，方便你明白正则是如何进行匹配的。这些原理性的知识，能够帮助我们快速理解为什么有些正则表达式不符合预期，也可以避免一些常见的错误。只有了解正则引擎的工作原理，我们才可以更轻松地写出正确的，性能更好的正则表达式。

## 有穷状态自动机

正则之所以能够处理复杂文本，就是因为采用了 **有穷状态自动机（finite automaton）。** 那什么是有穷自动机呢？

- 有穷状态是指一个系统具有有穷个状态，不同的状态代表不同的意义。

- 自动机是指系统可以根据相应的条件，在不同的状态下进行转移。

  从一个初始状态，根据对应的操作（比如录入的字符集）执行状态转移，最终达到终止状态（可能有一到多个终止状态）。

有穷自动机的具体实现称为正则引擎，主要有 DFA 和 NFA 两种，其中 NFA 又分为传统的 NFA 和 POSIX NFA：

- DFA：确定性有穷自动机（Deterministic finite automaton）
- NFA：非确定性有穷自动机（Non-deterministic finite automaton）
  - 传统的 NFA
  - POSIX NFA

接下来我们来通过一些示例，来详细看下正则表达式的匹配过程。

## 正则的匹配过程

在使用到编程语言时，我们经常会 「编译」一下正则表达式，来提升效率，比如在 Python3 中它是下面这样的：

```python
>>> import re
>>> reg = re.compile(r'a(?:bb)+a')
>>> reg.findall('abbbba')
['abbbba']
```

这个编译的过程，**其实就是生成自动机的过程**，正则引擎会拿着这个自动机去和字符串进行匹配。生成的自动机可能是这样的（下图是使用 [Regexper 工具生成](https://github.com/javallone/regexper-static)，再次加工得到的）。比如上图中的 `a(?:bb)+a` 可以 [使用在线的 Regexper 工具生成下图类似的图片](https://regexper.com/#a%28%3F%3Abb%29%2Ba) （友情提示：`(?:)` 小括号中的 `?:` 表示不捕获分组）

![img](./assets/e3e052fac55209937cfd20ab5117f24f.png)

在状态 s3 时，不需要输入任何字符，状态也有可能转换成 s1。你可以理解成 `a(bb)+a`  在匹配了字符 `abb` 之后，到底在 s3 状态，还是在 s1 状态，这是不确定的。**这种状态机就是非确定性有穷状态自动机（Non-deterministic finite automaton 简称 NFA）**。

**NFA 和 DFA 是可以相互转化的，** 当我们把上面的状态表示成下面这样，就是一台 DFA 状态机了，因为在 s0-s4 这几个状态，每个状态都需要特定的输入，才能发生状态变化。
